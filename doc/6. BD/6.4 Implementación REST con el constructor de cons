6.4 Implementación REST con el constructor de consultas (QUERY BUILDER)

Ahora ya teniendo conocimiento del diseño Rest, vamos a implementarlo utilizando el Query Builder de Laravel

Regresando donde nos quedamos con la aplicación inicial.

Si hacemos click en contactos, muestra el formulario para enviar un mensaje, Si se revisa el Diseño Rest, se puede observar que mas o menos se tiene implementada la segunda linea:


	
	Método HTTP 		URL							Acción 							Respuesta

	GET					/Messages 					MessagesController@index 		Todos los mensajes
*	GET 				/Messages/Create 			Messagescontroller@create 		Formulario de creación
	POST 				/messages 					MessagesController@store 		Guarda mensajes y redirecciona
	GET 				/messages/{id} 				MessagesController@show 		Un mensaje específico
	GET 				/messages/{id}/edit 		MessagesController@edit 		Formulario de edición
	PUT/PATCH 			/messages/{id} 				MessagesController@update 		Actualiza mensaje y redirecciona
	DELETE 				/messages/{id} 				MessagesController@destroy 		Elimina mensaje y redirecciona


Pero no esta siendo procesada por el MessageController, ni tampoco estamos utilizando la URL, entonces primero se tendra que crear el resources, en español,


Se va a reemplazar la palabra messages, por mensajes y solo que localice coincidencias en minusculas.

Se reemplaza y ahora si podemos implementar la linea:



	Método HTTP 		URL							Acción 							Respuesta

	GET					/mensajes 					MessagesController@index 		Todos los mensajes
*	GET 				/mensajes/Create 			Messagescontroller@create 		Formulario de creación
	POST 				/mensajes 					MessagesController@store 		Guarda mensajes y redirecciona
	GET 				/mensajes/{id} 				MessagesController@show 		Un mensaje específico
	GET 				/mensajes/{id}/edit 		MessagesController@edit 		Formulario de edición
	PUT/PATCH 			/mensajes/{id} 				MessagesController@update 		Actualiza mensaje y redirecciona
	DELETE 				/mensajes/{id} 				MessagesController@destroy 		Elimina mensaje y redirecciona



Lo primero que haremos sera crear el controlador, 

En la terminal escribimos:

	php artisan make:controller MessagesController	



Abrimos el controlador en Sublime 

MessagesController.php
---
	<?php

	namespace App\Http\Controllers;

	use Illuminate\Http\Request;

	class MessagesController extends Controller
	{
	    //
	}

---	

Se tiene el esqueleto de un controlador, dentro de las llaves se comenzarian a escribir los siete metodos que se necesitan para la implentación REST, sin embargo podemos Decirle a Laravel que haga el trabajo por nosostros, cada vez que necesitemos ver información sobre un comando, le anteponemos al comando -h, al comando que queremos investigar.

	php artisan -h make:controller


Para que se muestre la descripción del comando, tanto las opciones como los argumentos que podemos pasarle, vemos que el comando make:controller se tiene la opción llamada

	--resource	o recurso que al añadirla al comando nos generara un RESTFULL controller, es decir un controlador con todos los metodos necesarios, para la implementación de un recurso. Vamos a utilizarlo de la siguiente manera:


		 php artisan make:controller MessagesController --resource

Y entonces se creara el nuevo controlador con todos los metodos necesarios:



---
	<?php

	namespace App\Http\Controllers;

	use Illuminate\Http\Request;

	class MessagesController extends Controller
	{
	    /**
	     * Display a listing of the resource.
	     */
	    public function index()
	    {
	        //
	    }

	    /**
	     * Show the form for creating a new resource.
	     */
	    public function create()
	    {
	        //
	    }

	    /**
	     * Store a newly created resource in storage.
	     */
	    public function store(Request $request)
	    {
	        //
	    }

	    /**
	     * Display the specified resource.
	     */
	    public function show(string $id)
	    {
	        //
	    }

	    /**
	     * Show the form for editing the specified resource.
	     */
	    public function edit(string $id)
	    {
	        //
	    }

	    /**
	     * Update the specified resource in storage.
	     */
	    public function update(Request $request, string $id)
	    {
	        //
	    }

	    /**
	     * Remove the specified resource from storage.
	     */
	    public function destroy(string $id)
	    {
	        //
	    }
	}


---	 

Con las respectivas inyecciones de dependencias, y parametros.

Ya teniendo el controlador creado, podemos ahora crear una ruta que responda a  "/mensajes/create" o tambien podemos llamarle, "mensajes/crear".  

Lo que hara esto es ejecutar el metodo create desde el controlador en MessagesController@create, ahora en el archivo de rutas, al final escribimos:


	Route::get('mensajes/create', ['as' => 'messages.create']);

Daremos el nombre de messages.create, esta es una convención que vamos a utilizar a partir y utilizar de ahora en adelante, donde escribimos primero el nombre, del recurso, seguido por un punto que corresponde al metodo que se encuentra en el controlador.


Indicamos tambien que use el controlador MessageController y  que ejecute el metodo create.

routes.php


	Route::get('mensajes/create', ['as' => 'messages.create', 'uses' => 'MessagesController@create']);
	

Para comprobar que estamos utilizando este metodo, y antes de revisar en el navegador. Vamos a nuestro archivo de plantillas, para actualizar el menu de contactos.



Dentro de 
	layout.blade.php


Para que el link apunte a la ruta correcta, por ello copiamos de web.php y pegamos en "layout.blade.php"


Agregando la siguiente linea en:

	layout.blade.php

---

	<nav>
			<a class="{{ activeMenu('/') }}" href="{{ route('home') }}">Inicio</a>
			
			<a class="{{ activeMenu('saludos/*') }}" href="{{ route('saludos','Klvst3r') }}">Saludo</a>
			
			<!-- <a class="{{ activeMenu('contactame') }}" href="{{ route('contactos') }}">Contactos</a> -->
			<a class="{{ activeMenu('contactame') }}" href="{{ route('messages.create') }}">Contactos</a>  Esta es la lina modificada
		</nav>
---	


Ahora vamos al pages controller, para observar el metodo que devuelve la vista


PagesController.php
---

	 public function contact()
        {

            return view('contactos');
        }

---

Que es la vista que devuelve el formulario.

Ahora vamos a crear una vista para guardar la vista y todas las que necesitemos a futuro,


con la carpeta Messages, y dentro el archivo create.blade.php, copiando todo el codigo de la vista contacto.


/resources/views/messages/create.blade.php


---
	@extends('layout')

	@section('contenido')

	<h1>Contactos</h1>

	<h2>Escribeme</h2>

	@if(session()->has('info'))
		
		<h3>{{ session('info') }} </h3>

	@else

	<form method="POST" action="contacto">

		 <!-- @csrf -->
		

		 <input type="hidden" name="_token" value="{{ csrf_token() }}">


		 {!! csrf_field() !!} 


		  

		<p><label for="nombre">
			Nombre
			<input type="text" name="nombre" value={{ old('nombre') }}>
			{!! $errors->first('nombre', '<span class=error>:message</span>') !!}
		</label></p>
		
		<p><label for="email">
			Email
			<input type="text" name="email" value={{ old('email') }}>
			{!! $errors->first('email', '<span class=error>:message</span>') !!}
		</label></p>
		
		<p><label for="nombre">
			Mensaje
			<textarea name="mensaje"></textarea>
			{!! $errors->first('mensaje', '<span class=error>:message</span>') !!}

		</label></p>
		
		<input type="submit" value="Enviar">

	</form>

	@endif

	<hr>

	@stop
---


Eliminando el archivo o generando un respaldo.

Ahora en MessagesController en el metodo create() vamos a devolver la vista create

MessagesController.php
--

	   public function create()
    {
     
        return view('messages.create');
    }
--

Le decimos que en la carpeta messages utilice el archivo create y como ya sabemos no es necesario escribir la extensión blade.php

Ahora actualizamos en el navegador y ya podrremos ver el formulario. Y los links siguen funcionando.

Con esto ya tenemos implementado la acción "create" que devuelve un formulario dentro de suestro REST.

continuamos ahora con la parte de guardar el mensaje en la base de datos.

Regresamos al MessagesController en el metodo store() que es el metodo que se encargara de guardar los mensajes, por lo tanto de mometno vamos a guardar un string para asegurarnos de que estamos ejecutando este metodo cuando estamos ejecutando el formulario.


MessagesController
 ---
 	public function store(Request $request)
 	 {
        return "Guardar y direccionar";
      }

 ---

 Ahora vamos al formulario y cambiamos la acción, entonces en el archivo routes o en nuestro caso routes/web.php, duplicamos la ultima linea y cambiamos el metodo a post y la la url sera simplemente mensajes, el nombre de la ruta sera

 ---
 	Route::post('mensajes/create', ['as' => 'messages.store', 'uses' => 'MessagesController@store']);
 ---

Y utilizaremos el MessageController en el metodo store.

Bien, ahora vamos a utilizar la ruta anterior y la vamos a colocar en la acción del formulario dentro de create.blade.php

messages/create.blade.php

Cambiando de
	<form method="POST" action="contacto">

a: 	
---
	<form method="POST" action=" {{ route('messages.store') }}">

---

Escribimos la función route y por parametro el nombre de la ruta.

Llenamos el formualrio enviamos y efectivamante nos lleva a la ruta correcta, rentonces aqui ya tenemos acceso a los datos del formulario gracias a la clase Request, que Laravel no sinyecta automaticamente, vamos regresar todos los campos, para verificar que los estamos recibiendo.

MessageController.php
---

	public function store(Request $request)
    {

        return $request->all();
    }

--

Reenviamos y ahora podemos ver todos los campos que se han enviado del formulario.


	Respuesta:

		{
		"_token": "KYyZbPKfHRcHHcqLNLjUECv6ees5SAQ8IvrJqadh",
		"nombre": "Klvst3r",
		"email": "klvst3r@outlook.com",
		"mensaje": "Mensaje"
		}


Para cceder a un campo especifico, añadimos la función input() y por parametro le pasamos el nombre del campo.

---


public function store(Request $request)
    {

		return $request->input("nombre");
    }
---


Si queremos el nombre pegamo el id nombre, recargamos y  solo veremos el nombre.

salida:
	
	Klvst3r



Entonces, primero debemos guardar el mensaje, y luego redireccionar. Ahora si vamos a utiliar el Query Builder. Para ello utilizamos la clase DB. Y accedemos al metodo table(), para especificar la tabla que queremos consultar, si recordamos en secciones anteriores, creamos la migración

	2023_09_09_174616_create-messages_table.php


Donde llamamos a la tabla messages.


	...
	 Schema::create('messages', function (Blueprint $table) {
	...


Ahora escribimos esa tabla en MessageController.php, luego llamamos a la función insert, que sirve para insertar en la tabla y por parametro le pasamos un array asociativo con los valores que queremos guardar, primero en la columna nombre de la Bd quiero guardar el nombre que viene del formulario, luego hacemos lo smismo con el email, y con el mesnaje.


---

	public function store(Request $request)
    {

		DB::table('messages')->insert([
			"nombre" => $request->input('nombre'),
			"email" => $request->input('email'),
			"mensaje" => $request->input('mensaje'),

		]);
    }

---


Esto es todo lo que tenemos que hacer, no tenemos que preouparnos de la conexion de la Bd ni inyecciones SQL, ya que detras de escena estamos preparando las sentencias e insertandolas en la clase DBO, siguiendo las mejores practicas en PHP.

Entonces ahora solo nos queda redireccionar, por ahora regresemos el mensaje "Hecho", Regresando al navegador llenamos el formulario, enviamos y posible error.

Mensaje de error
	Error
							PHP 8.2.10
							10.14.1
	Mensaje de error:							
		Class "App\Http\Controllers\DB" not found



Esto indica que no encuentra la clase "App\Http\Controllers\DB", lo cual es obvio por que esa clase no existe, esto es por que olvidamos importar la clase al principio del archivo, esta tratando de buscar dentro del name espace siguiente, lo cual no quremos, queremos que utilice la siguiente:


	use DB;

En MessagesController.php

---
	<?php

	namespace App\Http\Controllers;

	use Illuminate\Http\Request;

	use DB;

	use App\Http\Request; //Esta linea es opcional en nuestra versión aun no la utilizamos y no fue creada con el controlador,
---	


Bien, reenviamos el formularió y vemos la palabra Hecho. Lo que quiere decir que si vamos al gestor de base de datos, y actualizamos podremos ver los datos que se han guardado correctamente.

select * from messages;
+----+---------+---------------------+-------+----------------------+------------+------------+
| id | nombre  | email               | phone | mensaje              | created_at | updated_at |
+----+---------+---------------------+-------+----------------------+------------+------------+
|  1 | Klvst3r | klvst3r@outlook.com | NULL  | Aqui esta el mensaje | NULL       | NULL       |
+----+---------+---------------------+-------+----------------------+------------+------------+
1 row in set (0.000 sec)



Lo que podemos observar es que los campos 'phone', created_at' y 'updated_at'. estan nulos, estos campos son utiles para auditorias, ya que guardamos las fechas de creación y actualización de los recursos.

Antes de agregarlos vamos a refrescar la BB

	php artisan migrate:refresh

Actualizamos y verificamos que no existen datos en la base de datos.

select * from messages;
	Empty set (0.001 sec)


Ahora en el editor en el archivo MessagesController.php agregamos el campo "created_at" y vamos a utilizar un paquete llamado Carbon que Laravel utiliza para manejar fechas, y llamamos al metodo now() para que imprima la fecha y hora actual y lo mismo para el campo "updated_at", no olvidando la clase Carbon arriba.


---

	...
	use Carbon\Carbon;
	...
	...
	public function store(Request $request)
    {

        DB::table('messages')->insert([
            "nombre" => $request->input('nombre'),
            "email" => $request->input('email'),
            "mensaje" => $request->input('mensaje'),
            "created_at" => Carbon::now(),
            "updated_at" => Carbon::now(),

        ]);

        return "Hecho";
    }

---

Reenviamos y revisamos la base de datos. y Efectivamente ya contamos con las fechas incorporadas.


elect * from messages;
+----+---------+---------------------+-------+----------------------+---------------------+---------------------+
| id | nombre  | email               | phone | mensaje              | created_at          | updated_at          |
+----+---------+---------------------+-------+----------------------+---------------------+---------------------+
|  1 | Klvst3r | klvst3r@outlook.com | NULL  | Aqui esta el mensaje | 2023-09-18 16:24:55 | 2023-09-18 16:24:55 |
+----+---------+---------------------+-------+----------------------+---------------------+---------------------+
1 row in set (0.001 sec)




Ahora vamos a redireccionar a la vista donde se muestren todos los mensajes.

	return redirect();

Esta vista aun no se ha creado, asi que primero vamos a crearla, en el archivo Routes, duplicamos cambiamos la URL ahora el nombre sera messages.index y  

web.php


---
	Route::get('mensajes', ['as' => 'messages.index', 'uses' => 'MessagesController@index ']);

---

Este sera el nombre de la ruta que vamos a utilizar, ahora en Messagecontroller vamos a aceder al metodo route


MessageController.php

---
	public function store(Request $request)
    {

        DB::table('messages')->insert([
            "nombre" => $request->input('nombre'),
            "email" => $request->input('email'),
            "mensaje" => $request->input('mensaje'),
            "created_at" => Carbon::now(),
            "updated_at" => Carbon::now(),

        ]);

     		return redirect()->route('messages.index');
    }
---


Por parametro le pasamos el nombre de la ruta, ahora vamos al navegador; llenamos el formulario, enviamos y efectivamente me redirecciona a la url mensajes, Si revisamos la Bd, tenemos el nuevo mensaje.

Ahora nos toca implementar el metodo index.


Vamos a probar que estamos 




Soluciones al error del metodo redirect

https://es.stackoverflow.com/questions/511404/reflectionexception-function-does-not-exist

https://stackoverflow.com/questions/68881408/laravel-8-reflectionexception-function-does-not-exist

https://laracasts.com/discuss/channels/laravel/function-does-not-exist

https://laracasts.com/discuss/channels/laravel/laravel-error-reflection-exception-function-does-not-exist


https://www.google.com/search?client=firefox-b-d&q=ReflectionException+PHP+8.1.10+10.14.1+Function+%28%29+does+not+exist


Routing con Laravel

	https://laravel.com/docs/10.x/routing


Solucionado el Error de Redirect to Index
	