6.5 Qué es ELOQUENT y refactorización de la implementación REST


 En la sección anterior se vio como utilizar el Query Builder de Laravel y se comento en la parte final que se puede rremplazar las sguientyes siete lineas, por una sola linea.




	//6.4. Redirección a los mensajes a index y regresando todos los mensajes
	Route::get('mensajes', ['as' => 'messages.index', 'uses' => 'MessagesController@index']);

	//6.4. Implementación del REST"
	Route::get('mensajes/create', ['as' => 'messages.create', 'uses' => 'MessagesController@create']);

	//6.4. Procesamiento del formulario 
	Route::post('mensajes', ['as' => 'messages.store', 'uses' => 'MessagesController@store']);

	//6.4. Mostrar un mensaje.
	Route::get('mensajes/{id}', ['as' => 'messages.show', 'uses' => 'MessagesController@show']);

	//6.4. Ruta para editar los mensajes
	Route::get('mensajes/{id}/edit', ['as' => 'messages.edit', 'uses' => 'MessagesController@edit']);

	//6.4. Ruta para actualizar los mensajes
	Route::put('mensajes/{id}', ['as' => 'messages.update', 'uses' => 'MessagesController@update']);


	//6.4. Ruta para eliminar los mensajes
	Route::delete('mensajes/{id}', ['as' => 'messages.destroy', 'uses' => 'MessagesController@destroy']);

 Se comienza por ahi:

 Vamos comentar un momento las rutas anteriores, para ver solo las de la implementación REST: 

 	/* 6.5 Se comenta para trabajar con ELOQUENT
	//3.1

	Route::get("/", ['as' => 'home', 'uses' => 'PagesController@home'])->middleware('example');


	Route::get('contactame', ['as' => 'contactos', 'uses' => 'PagesController@contact']);


	//Procesamiento del formulario
	Route::post('contacto', 'PagesController@mensajes');

	Route::get('saludos/{nombre?}', ['as' => 'saludos', 'uses' => 'PagesController@saludo'])->where('nombre', "[A-Za-z1-9]+");
	*/


Ahora vamos a la terminal y escribimos:

	php artisan r:l

Esto sirve para ver todas rutas de nuestra aplicación que es lo mismo que escribir:

	php artisan route:list


Resultado:
	

Domain      Method 		URI 								Name 												Action

			  POST      _ignition/execute-solution ........ ignition.executeSolution › Spatie\LaravelIgnition › ExecuteSolutionController
			  GET|HEAD  _ignition/health-check .................... ignition.healthCheck › Spatie\LaravelIgnition › HealthCheckController
			  POST      _ignition/update-config ................. ignition.updateConfig › Spatie\LaravelIgnition › UpdateConfigController
			  GET|HEAD  api/user ........................................................................................................ 
			  GET|HEAD  mensajes .............................................................. messages.index › MessagesController@index
			  POST      mensajes .............................................................. messages.store › MessagesController@store
			  GET|HEAD  mensajes/create ..................................................... messages.create › MessagesController@create
			  GET|HEAD  mensajes/{id} ........................................................... messages.show › MessagesController@show
			  PUT       mensajes/{id} ....................................................... messages.update › MessagesController@update
			  DELETE    mensajes/{id} ..................................................... messages.destroy › MessagesController@destroy
			  GET|HEAD  mensajes/{id}/edit ...................................................... messages.edit › MessagesController@edit
			  GET|HEAD  sanctum/csrf-cookie ........................... sanctum.csrf-cookie › Laravel\Sanctum › CsrfCookieController@show

			                                                                                                          Showing [12] routes


Aqui podemos ver todas las rutas de nuestra aplicación, entonces, ahora vamos a comentar estas siete lineas siguientes y ahora escribimos en el archivo de rutas web.php

		Route::resource('mensajes','MessagesController');

Rutas y el recurso; entonces, el recurso de nosotros es "mensajes"		 y por segundo parametro le pasamos el controlador encargado llamado "MessageController".


Si ahora volvemos a ejecutar php artisan r:l (route list) podemos ver que tenemos practicamente las mismas rutas que se tenian antes, con unas pequeñas diferencias.


Domain      Method 				URI 								Name 												Action

			  POST            _ignition/execute-solution .. ignition.executeSolution › Spatie\LaravelIgnition › ExecuteSolutionController
			  GET|HEAD        _ignition/health-check .............. ignition.healthCheck › Spatie\LaravelIgnition › HealthCheckController
			  POST            _ignition/update-config ........... ignition.updateConfig › Spatie\LaravelIgnition › UpdateConfigController
			  GET|HEAD        api/user .................................................................................................. 
			  GET|HEAD        mensajes ........................................................ mensajes.index › MessagesController@index
			  POST            mensajes ........................................................ mensajes.store › MessagesController@store
			  GET|HEAD        mensajes/create ............................................... mensajes.create › MessagesController@create
			  GET|HEAD        mensajes/{mensaje} ................................................ mensajes.show › MessagesController@show
			  PUT|PATCH       mensajes/{mensaje} ............................................ mensajes.update › MessagesController@update
			  DELETE          mensajes/{mensaje} .......................................... mensajes.destroy › MessagesController@destroy
			  GET|HEAD        mensajes/{mensaje}/edit ........................................... mensajes.edit › MessagesController@edit
			  GET|HEAD        sanctum/csrf-cookie ..................... sanctum.csrf-cookie › Laravel\Sanctum › CsrfCookieController@show

			                                                                                                          Showing [12] routes

Esto no va a funcionar todavia, Ya que lo que hace Laravel es utilizar el nombre del recurso para generar las URI y los nombres de las rutas, aca podemos ver que el parametro se ha llamado diferente, pero este no es el problema por que en el controlador podemos llamarle como queramos.


	Nombre o prfijo de rutas 		URI 				
	messages.index 					mensajes

La razon por la que no va a funcionar es por que se esta utilizando messages.index, en los nombres prefijos de las rutas, y mensajes en la URI, y en las rutas que se acaban de crear, tanto el prefijo de las rutas como el URI soniguales  

	Nombre o prfijo de rutas 		URI 				
	mensajes.index 					mensajes

Ahora, si le cambiamos el nombre del recurso como sigue:

		Route::resource('menssages','MessagesController');

Y ejecutamos el comando de route list.




Domain      Method 				URI 								Name 												Action
			  POST            _ignition/execute-solution .. ignition.executeSolution › Spatie\LaravelIgnition › ExecuteSolutionController
			  GET|HEAD        _ignition/health-check .............. ignition.healthCheck › Spatie\LaravelIgnition › HealthCheckController
			  POST            _ignition/update-config ........... ignition.updateConfig › Spatie\LaravelIgnition › UpdateConfigController
			  GET|HEAD        api/user .................................................................................................. 
			  GET|HEAD        messages ........................................................ messages.index › MessagesController@index
			  POST            messages ........................................................ messages.store › MessagesController@store
			  GET|HEAD        messages/create ............................................... messages.create › MessagesController@create
			  GET|HEAD        messages/{message} ................................................ messages.show › MessagesController@show
			  PUT|PATCH       messages/{message} ............................................ messages.update › MessagesController@update
			  DELETE          messages/{message} .......................................... messages.destroy › MessagesController@destroy
			  GET|HEAD        messages/{message}/edit ........................................... messages.edit › MessagesController@edit
			  GET|HEAD        sanctum/csrf-cookie ..................... sanctum.csrf-cookie › Laravel\Sanctum › CsrfCookieController@show

			                                                                                                          Showing [12] routes

Ahora vemos que tenemos messages en la URI y messages.index en el prefijo, y de esta forma tampoco nos va a servir, ya que en la svistas y en el controlador se ha hecho referencias al prefijo messages de las rutas. Esto se ha mostrado asi para que la URI, se ve en español tambien, entonces, lo que se debe de hacer es buscar y reemplazar estas referencias de rutas que se hicieron en el prefijo messages.


Entonces, si accedemos a la ruta Contactos del menu seguramente marcara un error (es decir a la url): http://localhost:8000/mensajes/create se generar un error 404 recurso no encontrado.

Internamente resultado de:

	ErrorException in URlGenerator.php

	Resource [messages.store] not defined. (View:
	/Users/klvst3r/Code/laravel/resources/views/messages/create.blade.php)

Indicando que la ruta messages.store no esta definida, el problema es que estamos buscando messages.store y hemos definido mensajes.store, todas las 7 rutas se escribieron manualmente para mostrar como esta contruida cada una de ellas pero por lo egeneral, si vamos a ocupar recursos al estilo REST, lo primero que se tiene que hacer es escribir la linea que sigue, y que se ha utilizando anteriormente:


	Route::resource('mensajes','MessagesController');

Y asi evitamos el inconveniente por el que estamos pasando ahora.


Entoces, lo que debemos hacer es buscar la referencia anterior y cambiarlas, afortunadamente la solución es mas sencilla de lo que parece, en Sublime Text, podemos precionar: 	

	CTRL + SHIFT + F para buscar y reenplazar

		Find: La cadena que queremos buscar y en el segundo campo podemos definir en que carpeta buscar..


Entonces, buscamos 

	route('mensajes. 

Reemplazarlo por 

	route('mensajes. 	


Apareciendo todas las coincidencias, en el MessagesController, en el archivo de plantillas, etc.

Entonces, lo que vamos a hacer es presionar nuevamente CTRL + SHIFT + F,  y le vamos a indicar en reemplazar encontrando 15 coincidencias, indicamos que si queremos rremplazar las 27 coincidencias en 8 de nuestros archivos.

	Inclusive ha actualizado el archivo laravel.log y algunas vistas ya compliladas.

Que aunque no era necesario, no se ve ningun problema.

Vamos al menu archivo y guardamos todo para que se guarden todos los archivos abiertos. Cerramos toso los archiso siendo estos los siguientes:

	- layout.blade.phpcostal

	
	- create.blade.php
	- edit.blade.php
	- index.blade.php
	- MessageController.php
	- web.php


Si accesamos ahora a la liga de inicio siguiente, 

	http://localhost:8000/saludos/Klvst3r

El menu se 

Ahora si actualizamos veremos nuevamente un error que dice, refrescamos en nuestra aplicación, reempazando en las vistas de los mensajes, en el MessageController y en el archivo de ocnfiguración web.php

Seran 15 las coincidencias a reemplazar, y aceptamos, incluso se puede actualizar el archivo log de algunas vistas ya compiladas que no eran necesarias, pero no existe inconveniente, ahora vamos al menu archivo y cerramos todas las pestañas abiertas y modificadas.

Cerramos con CTRL + W y si actualizamos podemos ver que nuestra aplicación esta nuevamente funcional, o en algun caso puede presentar el error en la ruta home no esta definida como en nuestro caso ocurrio.

Una forma de solucionar este inconveniente es descomentar las siguientes lineas en las rutas web.php

	
	Route::get("/", ['as' => 'home', 'uses' => 'PagesController@home'])->middleware('example');


	Route::get('contactame', ['as' => 'contactos', 'uses' => 'PagesController@contact']);


	//Procesamiento del formulario
	Route::post('contacto', 'PagesController@mensajes');

	Route::get('saludos/{nombre?}', ['as' => 'saludos', 'uses' => 'PagesController@saludo'])->where('nombre', "[A-Za-z1-9]+");



Ahora si podremos tener nuevamente funcional nuestra aplicación


Probamos las opciones de la aplicacion, editando, registrando, eliminando y visualizando los mensajes de nuestra aplicación.

Todo esta funcionando como antes, pero nuestro archivo de rutas ahora esta mucho más limpio, entonces, ahora para entrar ya en materia.

Se abre el MessageController y antes de utilizar ELOQUENT vamos a entender un poco lo que es en si ELOQUENT,


ELOQUENT es el ORM que viene con Laravel.

Un ORM se entiende por "Object-Relational Mapping" o "Mapeo Objeto-Relacional" en palabras simples es la representación de una tabla, de una base de datos en Objetos o clases de una aplicación


Resumiendo:

				ORM


		Object-Relational Mapping

		  Mapeo Objeto-Relacional


	Tabla = messages => Clase = Message



Por ejemplo en nuestro caso la tabla messages la vamos a representar como una clase heredada de ELOQUENT llamada Message	

	Tabla = messages => Clase = Message

Para crearla en la terminal escribimos php artisan para ver el estado de los comandos disponibles y debajo del nameespace make, tenemos este comando llamado 

	make:model

Que es el que necesitamos.

Escribimos 

	php artisan make:model <nombre_modelo>


Aca hay otra convención que vamos a seguir, los modelos los nombramos igual que la tabla a la que sera asociada pero en singular y con la primera letra en mayusculas, es decir la tabla que queremos asociar se llama messages por lo tanto el nombre del modelo sera: Message en singular.

Ejecutamos y si vamos a la carpeta App podemos ver el modelo.

	php artisan make:model Message


La ruta de nuestro nuevo modelo estara en:

/app/Http/Models/Message.php

Lo abrimos y observamos que no es mas que una clase heredada del modelo ELOQUENT

	---

	<?php

	namespace App\Models;

	use Illuminate\Database\Eloquent\Factories\HasFactory;
	use Illuminate\Database\Eloquent\Model;

	class Message extends Model
	{
	    use HasFactory;
	}


	---


Ahora ya podemos comenzar a utilizar. Volvemos al MessageController, y en el metodo index, en lugar de utilizar el Query Builder vamos a utilizar Eloquent:

	---


        public function index()
        {

            $messages = DB::ta ble('messages')->get(); 

            $message = Message::all();

            return view('messages.index', compact('messages'));            

        }

	---

Se crea la variable Messages, y en el modelo accedemos al metodo All, para obtener todos los mensajes de la tabla, por ultimo debemos importar la clase Message al principio del archivo.

	---	

		<?php

		namespace App\Http\Controllers;

		use Illuminate\Http\Request;

		use DB;

		//**Se importa la clase para emplear ELOQUENT
		use App\Models\Message;

		use Carbon\Carbon;

		use App\Http\Controllers\MessagesController;

	---	

Notese que aca no se especifica la tabla 'messages', entonces como sabe el modelo a que tabla consultar. Laravel automaticamente va a buscar una tabla en la Base de datos que tenga el mismo nombre que el modelo pero en minusculas y en plural, entonces Laravel va a asumir que nuestra Tabla se llama 'messages' , en este caso es correcto, nuestra tabla se llama 'messages' 

---
	<?php

	namespace App\Models;

	use Illuminate\Database\Eloquent\Factories\HasFactory;
	use Illuminate\Database\Eloquent\Model;

	class Message extends Model
	{
	    use HasFactory;
	    //messages
	}


---


pero si queremos utulizar otro nombre para la tabla, podemos agregar la propiedad table y asignar el nombre de la tabla:


---
	
	<?php

	namespace App\Models;

	use Illuminate\Database\Eloquent\Factories\HasFactory;
	use Illuminate\Database\Eloquent\Model;

	class Message extends Model
	{
	    use HasFactory;
	    //messages
	    protected $table = 'nombre_de_mi_tabla'
	}


---


Vamos a borrarlo ya que nuestro valor por defecto nos sirve. Entonces en el MessageController se comenta la primera linea

	//$messages = DB::table('messages')->get(); 

Y la variable es $messages, en plural ya que estamos recibiendo todos los mensajes de la tabla. Actualizamos el navegador y verificamos el istado de los mensajes en la vista index.

	
--- Vista Index

	Inicio Saludo Contactos Mensajes
		Todos los mensajes
		ID	Nombre			Email				Mensaje							Acciones
		1	Klvst3r editado	klvst3r@outlook.com	Aqui esta el mensaje editado	Editar Eliminar
		2	Segundo			klvst3r@outlook.com	Aqui esta el segundo mensaje	Editar Eliminar
		3	Klvst3r			klvst3r@outlook.com	Mensaje por redirección			Editar Eliminar	
	Copyright ℗ 2023

---


Este tipo de operaciones realizadas con Eloquent las podemos realizar directamente desde un controlador, o ruta y automaticamente seran convertidas en formato JSON, 

Para visualizar en Messagens comabiamos de

	$messages = Message::all();

A una vista en JSON con


[
	{
	"id": 1,
	"nombre": "Klvst3r editado",
	"email": "klvst3r@outlook.com",
	"phone": null,
	"mensaje": "Aqui esta el mensaje editado",
	"created_at": "2023-09-18T16:24:55.000000Z",
	"updated_at": "2023-10-08T01:33:26.000000Z"
	},
	{
	"id": 2,
	"nombre": "Segundo",
	"email": "klvst3r@outlook.com",
	"phone": null,
	"mensaje": "Aqui esta el segundo mensaje",
	"created_at": "2023-09-18T17:00:17.000000Z",
	"updated_at": "2023-10-08T02:12:44.000000Z"
	},
	{
	"id": 3,
	"nombre": "Klvst3r",
	"email": "klvst3r@outlook.com",
	"phone": null,
	"mensaje": "Mensaje por redirección",
	"created_at": "2023-09-18T17:01:29.000000Z",
	"updated_at": "2023-09-18T17:01:29.000000Z"
	}
]


Si queremos ver el formato JSON como este tendremos que utilizar una exten´sión de Chrome se llama JSON Formater y es una extensión grauita.

Entonces ahora ya podemos eliminar la linea de JSON y dejarla tal cual estaba 


Bajando un poco en el MessageController, no estamos utilizando el Query Builder, en el metodo create. Nos detenemos en el metodo store, ya que existen varias forma de guardar datos con Eloquent:

- Vamos a revisar dos formas
Comentamos las lineas siguientes del Query Builder

1. La primera forma es creando una nueva instancia de la clase message o el modelo Message y guardarla en una variable, esta variable, esta variable es ahora un objeto llamado mensaje pero en blanco, asi que accedemos a la pripiedad nombre y le asignamos el nombre que viene del formulario:


	$message = new Message;

    $message->nombre = $request->input('nombre');

Hacemos lo mismo con el email
       $message->email = $request->input('email');     

Y el mensaje  
        $message->mensaje = $request->input('mensaje');     

Por ultimo con el metodo save, guardamos el mensaje en la Bd
		$message->save();        

Probamos, en la pagina del formulario de contactos, llenamos el formulario y antes de enviar debemos notar algo, del segmento de codigo anterior, ya que no se le estan pasando las fechas que se hacia con el Query Builder, con Eloquent no es necesario especificarlas, ya que son añadidas automaticamente.

Probamos y verificamos que sigue funcionando, si se revisa en la base de datos se observa que los datos de las fechas fueron agregados correctamente
	
	Registro almacenado en la Base de datos
	17 	Eloquent 	eloquent@laravel.com 	NULL 	Almacenemiento con Eloquent 1ra forma 	2023-10-11 04:44:25 	2023-10-11 04:44:25



Segunda forma de almacenamiento con Eloquent
--------------------------------------------

La segunda forma de almacenamiento que es la que puede utilizarse con mayor frecuencia, comentando dentro de MessageController la primera forma de almacenamiento


Ahora vamos a utilizar el metodo create directamente el el modelo, y por parametro podriamos pasarle un array similar al que sigue sin las fechas:


	        Message::create([
            "nombre" => $request->input('nombre'),
            "email" => $request->input('email'),
            "mensaje" => $request->input('mensaje'),

        	]);

O podemos pasarle todo el reuqest que viene del formulario de la siguiente forma:

	Message::create($request->all());


Pero esto no va a funcionar	aun, si intentamos guardar otro mensaje, se desplegara el siguiente error 

	MassAssignmentException in Model.php : 	__token


Esta es una protección que viene con Laravel por defecto y que nos protege de una posible asignación masiva de datos.



Que significa Asignación Masiva de Datos	


Cuando utilizamos el metodo create y tambien el metodo update pasamos un array:

	Ej.
		Message::create($request->all( ));

Laravel lo que hace es utilizar las llaves de este array y buscar una columna en la tabla para asignarle el valor de la misma.


Veamos como esta formado el array que estamos pasando:

	hacemos un dump and die que permite inspeccionar la variable e inmediatamente terminar la petición.

		dd()


	dd($request->all());

Es decir que cualquier linea de codigo que venga despues des esta funcion no se ejecutara.

Ahora si reenviamos el formulario podemos ver el array que le estamos pasando al metodo  create. 

		
        //Opcion dos

        dd($request->all());

        Message::create($request->all());
        

Resultado:

Podemos ver el array:

	array:4 [▼ // app/Http/Controllers/MessagesController.php:123
	  "_token" => "41iN0joxjtZ4TR4BJnaXVeJGndcoISxgXDbbG3rH"
	  "nombre" => "Token"
	  "email" => "token@segunda.forma"
	  "mensaje" => "Se envia información en un array"
	]


Entonces lo que hace Eloquent es buscar en la tabla una columna con el nombre _token. 


en la base de datos no existe un acolumna con el nombre _token


	MariaDB [applaravel]> select * from messages;
+----+---------+---------------------+-------+--------------------------------------------------------------------+---------------------+---------------------+
| id | nombre  | email               | phone | mensaje                                                            | created_at          | updated_at          |
+----+---------+---------------------+-------+--------------------------------------------------------------------+---------------------+---------------------+
|  1 | Klvst3r | klvst3r@outlook.com | NULL  | Aqui esta el mensaje                                               | 2023-09-18 16:24:55 | 2023-09-18 16:24:55 |
|  2 | Klvst3r | klvst3r@outlook.com | NULL  | Aqui esta el mensaje                                               | 2023-09-18 17:00:17 | 2023-09-18 17:00:17 |
|  3 | Klvst3r | klvst3r@outlook.com | NULL  | Mensaje por redirección                                            | 2023-09-18 17:01:29 | 2023-09-18 17:01:29 |
|  4 | Klvst3r | klvst3r@outlook.com | NULL  | Redirección a Index                                                | 2023-09-18 17:03:34 | 2023-09-18 17:03:34 |
|  5 | Klvst3r | klvst3r@outlook.com | NULL  | Nueva redirección de listado de mensajes                           | 2023-09-18 17:15:12 | 2023-09-18 17:15:12 |
|  6 | Klvst3r | klvst3r@outlook.com | NULL  | Envio con redirección a index                                      | 2023-09-18 17:19:26 | 2023-09-18 17:19:26 |
|  7 | Klvst3r | klvst3r@outlook.com | NULL  | Envio con redirección a index                                      | 2023-09-18 17:19:34 | 2023-09-18 17:19:34 |
|  8 | Klvst3r | klvst3r@outlook.com | NULL  | Envio con redirección a index                                      | 2023-09-18 17:21:30 | 2023-09-18 17:21:30 |
|  9 | Klvst3r | klvst3r@outlook.com | NULL  | Envio con redirección a index                                      | 2023-09-18 17:25:48 | 2023-09-18 17:25:48 |
| 10 | Klvst3r | klvst3r@outlook.com | NULL  | Mensaje para antes de redireccionar a index antes de la nueva ruta | 2023-09-18 18:05:33 | 2023-10-10 20:04:31 |
| 13 | Kozlov  | kozlov@gmail.com    | NULL  | Aplicación con nueva ruta                                          | 2023-10-10 20:03:24 | 2023-10-10 20:03:24 |
+----+---------+---------------------+-------+--------------------------------------------------------------------+---------------------+---------------------+
11 rows in set (0.000 sec)




Lo que se hara antonces temporalmente es quitar el token del formulario:

Eliminando de create.blade.php la siguiente linea 


	 {!! csrf_field() !!} 

Y deshabilitar la protección  CSRF para la ruta mensajes dentro del archivo VerifyCsrfToken.php

En app/Http/middleware/VerifyCsrfToken.php


		class VerifyCsrfToken extends Middleware
{
    /**
     * The URIs that should be excluded from CSRF verification.
     *
     * @var array<int, string>
     */
    protected $except = [
        
        'mensajes'
    ];
}





Ahora volvemos a llenar el formulario enviamos y verificamos nuevamente el array recibido.

	array:3 [▼ // app/Http/Controllers/MessagesController.php:123
	  "nombre" => "Token"
	  "email" => "quitar@token.formulario"
	  "mensaje" => "Se envia información en un array sin token"
	]


Ahora si tenemos solamente los tres campos que necesitamos (nombre, email y mensaje).Y aun asi si quitamos la siguiente linea, y se reenvia el mensaje

	 dd($request->all());


Vuelve a aparecer el error de MassAssignmentException de Error de asignación masiva, pero esta vez esta tratando de ingresar el nombre, en la BD, vemos que si tenemos una columna llamada nombre, 


PHP 8.2.11
10.14.1

		Illuminate\Database\Eloquent\MassAssignmentException

		Add [nombre] to fillable property to allow mass assignment on [App\Models\Message].



Cual es el problema entonces. Eloquent necesita que seamos especificos con los datos que queremos asignar, vamos a asignar temporalmente esta protección para entender por que es importante que no permitamos la asignación masiva, escribimos en MessagesController

Deshabilitamos la protección de asignación masiva

	
		Model::unguard(); 


E importamos la clase model al principio del archivo.

	use Illuminate\Database\Eloquent\Model;

Con la linea que se agrego, estamos deshabilitando la protección de asignación masiva. Volviendo al navegador parece que ahora esta funcionando.

Si podemos guardar los datos correctamente, cual es el problema con la asignación masiva, en la gran mayoria de los casos, en las tablas utilizamos identificadores unicos, autoincrementables. Que se añaden automaticamente cuando ingresamos datos, por regla general no debemos permitir que nadie, agregue o cambie este identificador, ya que puede causar mucho desorden, en nuestra aplicación. Sin embrago, cualquier usuario mal intencinado pudiera  manipular el formulario y agregar un campo de id directamente en el navegador y al no estar protegido contra esta asignación masiva, el usuario malintencionado lograra su cometido, para demostrar esto; inspeccionamos los elementos del formulario en el navegador. Buscamos cualquier fragmento dentro del formulario y hacemos click en editar HTML dupliao y cambiamos el label y el nombre del input quedando:

	
Editar como HTML

---
	<p><label for="id">
		Id
		<input type="text" name="id" value="">
		
	</label></p>
    <p><label for="nombre">
		Nombre
		<input type="text" name="nombre" value="">
		
	</label></p>
---	


Luego llenamos el formulario, y trataremos de que el mensaje se agregue en la base de datos con un id igual a 3, al enviar vemos que efectivamente el nuevo campo tine un identificador numero 3, esto se torna aun más peligroso, cuando actualizamos datos de la base de datos, ya que facimente podriamos cambiar el identificador del mensaje y hacerlo pasar por otro mensahe, incluso Si agregamos el campo "phone" y lleamos el formulario, Al enviar vemos que  tambien lo agrega.


Definitivamente no queremos esto, estamos permitiendo que se agreguen campos adicionales a los que definimos en el formulario, sin nuestra autorización. Imaginamos que el campo phone sea para varificar si un usuario es administrador del sitio. Seria un error fatal permitir que el usuario lo cambie, por lo tanto  para termiunar el tema de la asignación masiva.


En el modelo Message.php debemos agregar una propiedad llamada $fillable con un array de los campos que permitiremos al usuario masivamente, en este caso solo caso solo queremos que el usuario solo ingresar masivamente, en este caso queremos que el usuario ingrese el nombre, el email y el mensaje.

Message.php

	<?php

	namespace App\Models;

	use Illuminate\Database\Eloquent\Factories\HasFactory;
	use Illuminate\Database\Eloquent\Model;

	class Message extends Model
	{
	    use HasFactory;

	    //messages
	    protected $fillable = ['nombre','email','mensaje'];

	}



No permitiremos que envien mas que esto, 

	

Entonces auitamos la siguiente linea en MessagesController.php

	        //Model::unguard();

Para volver a tener la protección, agregamos un campo id	        


---
	<p><label for="id">
		Id
		<input type="text" name="id" value="">
		
	</label></p>
    <p><label for="nombre">
		Nombre
		<input type="text" name="nombre" value="">
		
	</label></p>
---	


Agregamos un campo phone


---
	<form method="POST" action=" http://localhost:8000/mensajes">

	 <!-- <input type="hidden" name="_token" value="41iN0joxjtZ4TR4BJnaXVeJGndcoISxgXDbbG3rH"> -->
	

<!-- 	 <input type="hidden" name="_token" value="41iN0joxjtZ4TR4BJnaXVeJGndcoISxgXDbbG3rH"> -->


	 <!-- <input type="hidden" name="_token" value="41iN0joxjtZ4TR4BJnaXVeJGndcoISxgXDbbG3rH">  -->


	  

	<p><label for="id">
		Id
		<input type="text" name="id" value="">
		
	</label></p>
 <p><label for="phone">
		Phone
		<input type="text" name="phone" value="">
		
	</label></p>
    <p><label for="nombre">
		Nombre
		<input type="text" name="nombre" value="">
		
	</label></p>
	
	<p><label for="email">
		Email
		<input type="text" name="email" value="">
		
	</label></p>
	
	<p><label for="mensaje">
		Mensaje
		<textarea name="mensaje"></textarea>
		

	</label></p>
	
	<input type="submit" value="Enviar">

</form>

---

Llenamos el formulario, enviamos y  verificamos en la base de datos y que aunque enviamos el id y phone por el formulario Eloquent los ha ingnorado y solo ha guardado el nombre, el email y el mensaje. Que fueron los que se definieron en la propiedad $filable.

Esta es la razon por lq que Laravel nos protege automaticamente de este problema de asignación masiva de datos.


 select * from messages;
+----+-------------+-------------------------+-------+----------------------------------------------+---------------------+---------------------+
| id | nombre      | email                   | phone | mensaje                                      | created_at          | updated_at          |
+----+-------------+-------------------------+-------+----------------------------------------------+---------------------+---------------------+
|  1 | Klvst3r     | klvst3r@outlook.com     | NULL  | Aqui esta el mensaje                         | 2023-09-18 16:24:55 | 2023-09-18 16:24:55 |
|  2 | Klvst3r     | klvst3r@outlook.com     | NULL  | Aqui esta el mensaje                         | 2023-09-18 17:00:17 | 2023-09-18 17:00:17 |
|  3 | Klvst3r     | klvst3r@outlook.com     | NULL  | Mensaje por redirección                      | 2023-09-18 17:01:29 | 2023-09-18 17:01:29 |
|  4 | Klvst3r     | klvst3r@outlook.com     | NULL  | Redirección a Index                          | 2023-09-18 17:03:34 | 2023-09-18 17:03:34 |
|  5 | Klvst3r     | klvst3r@outlook.com     | NULL  | Nueva redirección de listado de mensajes     | 2023-09-18 17:15:12 | 2023-09-18 17:15:12 |
|  6 | Klvst3r     | klvst3r@outlook.com     | NULL  | Envio con redirección a index                | 2023-09-18 17:19:26 | 2023-09-18 17:19:26 |
|  7 | Klvst3r     | klvst3r@outlook.com     | NULL  | Envio con redirección a index                | 2023-09-18 17:19:34 | 2023-09-18 17:19:34 |
|  8 | Klvst3r     | klvst3r@outlook.com     | NULL  | Envio con redirección a index                | 2023-09-18 17:21:30 | 2023-09-18 17:21:30 |
|  9 | Klvst3r     | klvst3r@outlook.com     | NULL  | Envio con redirección a index                | 2023-09-18 17:25:48 | 2023-09-18 17:25:48 |
| 10 | Klvst3r     | klvst3r@outlook.com     | NULL  | Redireccionar a index antes de la nueva ruta | 2023-09-18 18:05:33 | 2023-10-12 21:10:50 |
| 13 | Kozlov      | kozlov@gmail.com        | NULL  | Aplicación con nueva ruta                    | 2023-10-10 20:03:24 | 2023-10-10 20:03:24 |
| 14 | Asignación  | asignacion@masiva.datos | NULL  | Asignación masiva de datos                   | 2023-10-12 21:08:53 | 2023-10-12 21:08:53 |
+----+-------------+-------------------------+-------+----------------------------------------------+---------------------+---------------------+
12 rows in set (0.000 sec)




Ahora podemos ya no utilizar todas las lineas comentadas, en mi caso se quedan para el seguimiendo y documentación del codigo.

El mathodo ahora queda con apenas dos lineas de codigo en nuestro Message Controller


---
	public function store(Request $request)
    {

    	Message::create($request->all());
    

        return redirect()->route('mensajes.index');

        
    }

---    



Metodo Show
-----------



Ahora escribimos la variables y sera igual al modelo Message con el metodo fine que por parametro recibe el id

	$message = Message::find($id);

Esto es todo lo que tenemos que hacer

Se comenta la linea anterior y queda:

	//6.5 Mostrar Mensajes con Eloquent

        $message = Message::find($id);

        return view('messages.show', compact('message'));

En el navegador ahora hacemos click sobre uno de los mensajes para ver el detalle del mismo, vemos que funciona.


Que pasa si trato encontrar un mensaje con un identificador que no existe, por ejemplo en la url utilizamos

	http://localhost:8000/mensajes/2288

Accedemos y veremos el siguiente error:


	ErrorException

	Trying to get property of non-object (View:  .../laravel/resources/views/messages/show.blade.php)	

	Attempt to read property "nombre" on null

	Illuminate\Foundation\Bootstrap\HandleExceptions:8 handleError


Me dice que esta tratando de acceder a una propiedad que no es un objeto. Si vamos al metodo show, podemos ver que estamos tratando de acceder a


	@extends('layout')

	@section('contenido')

	<h1>Mensaje</h1>

	<p>Enviado por {{ $message->nombre }} - {{ $message->email }}</p>

	<p>{{ $message->mensaje }}</p>
	
	@stop

En esta linea:

	<p>Enviado por {{ $message->nombre }} - {{ $message->email }}</p>


Veremos que estamos tratando de acceder a la propiedad nombre, pero como no encontro ningun mensaje, con ese Id esta variable estaria NULL, y es como si estuvieramos haciendo lo siguiente:

	<p>Enviado por {{ null->nombre }} - {{ $message->email }}</p>	

Estariamos accediendo a una propiedad que no es un objeto. Pero entonces como hacemos para evitar esto.


Hay algunas formas recomendando la más sencilla, y que se utilizan comuinmente que es utilizando el metodo:

	findOrFail()

Encuantra o falla, si actualiza la pagina lo que hace es enviar dos errores:

	$message = Message::findOrFail($id);


Ahora no enviara un error 404 Pagina no encontrada.

	Sorry, the page you are looking for could not be found

	Not foundHttpException in Handler 
	
	No query results for model [App\Message]

Y como segundo error es del modelo no encontrado:

	ModelNotFoundException in Builder.php


Si se abre un pestaña, 



16:40



